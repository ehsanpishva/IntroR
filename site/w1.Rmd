---
title: "Introduction to R"
author: "Ehsan Pishva"
output: html_document
date: "16-04-2021"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

<br>

### **Downloads**
#### Presentation
[Click here to download the presentation](https://www.dropbox.com/s/c10xwgg6cf1jfok/Introduction%20to%20R%20%28PSY4373%29.pdf?dl=0)

#### R-script
[Click here to download the R-scripts used in week 1](https://www.dropbox.com/s/k4ozbyu8if7swdi/Week1.R?dl=0)

---
<br>
<br>

### **Types of data in R**

    Vectors
    Matrices
    Data Frames
    Arrays
    Lists
    Factors

#### **Vectors**
Commonly used atomic vector types in R:

    character: “a”, “swc”
    numeric: 2, 15.5
    integer: 2L (the L tells R to store this as an integer)
    logical: TRUE, FALSE

By atomic, we mean the vector only holds data of a single type.
<br>

#### **character/string vectors**
```{r code1}
#Code 1
x <- c("Male", "Male", "Female", "Female")
x
```

```{r code2}
x <- "Hello World!"
x
```
Note: 'x' is overwritten character strings need to be in quotes and can have spaces
<br>

#### **numeric vectors**
```{r code3}
x <- 2.5
x
```
can also use = , but better use <-
```{r code4}
x = 5
x
```

```{r code5}
x <- c(2,5,4)
x
```
Note: c() is the 'combine' function
<br>

You can create a vector of **consecutive numbers**
```{r code6}
x <- c(20:100)
x
```
you don't even need **c()** here
```{r code7}
x <- 20:100
x
```
Note: if the vector is too long to fit into a single line, the output is wrapped and the numbers in brackets (e.g., [1]) indicate the position of the value that comes next
<br>

if you mix numbers and strings, you get a character vector
```{r code8}
x <- c("Bob", "Sue", "John", 2, 5)
x
```
Note: this is called 'type conversion' and R uses a complex set of rules to do so in various circumstances (for better or for worse ...)
<br>

#### **logical vectors** 
```{r code9}
x <- c(TRUE, FALSE, FALSE)
x
```
can be abbreviated to T/F, but better avoid this
```{r code10}
x <- c(F, F, T)
x
```
<br>

#### How to check what objects are created in the workspace?
```{r code11}
x<-1
y<-2
z<-55

ls()
```
#### How to remove an object or clear the entire workspace?
```{r code12}
rm(x)
ls()

rm(list=ls())
ls()
```
or even better: restart the R session (Menu 'Session' - Restart R) 
<br>

##### **missing values**
```{r code13}
#x <- c(2,,4)
#x <- c(2, ,4)
x <- c(2, NA, 4)
x
```
note: NA = not available (another special keyword)
<br>

<br>

### **Comparisons** 
```{r code14}
x <- c(2, 4, 6, 3, 5)
x
```
<br>

```{r code15}
x > 3
x >= 3
x < 3
x <= 3
x == 3
x != 3
```
Note: they lead to logicals

<br>

#### **and/or** 
```{r code16}
(x > 3) & (x < 6)
(x < 3) | (x > 5)
```
Note: The parentheses are not necessary here, but make the code clearer

<br>

and/or (where the values located in the data?)
```{r code17}
x
which((x > 3) & (x < 6))
which((x < 3) | (x > 5))
```
Note: they lead to numeric

<br>

#### object/variable names **should**:
- must begin with a letter
- contain alphanumeric symbols (A-Z, a-z, 0-9)
- can also use . and _
- are case-sensitive
- no (relevant) restriction on length
<br>

#### names **should not:**
- correspond to commands (confusion/errors)
- contain spaces


#### check if something is a **command** or **name**?
simply type the name and run this
```{r code18}
mean
```
better avoid naming objects after commands -> confusing!
<br>

<br>

```{r code19}
mean <- c(2, 3, 4)
mean
mean(mean)
```
#### 'named' vectors
```{r code20}
age <- c(25, 21, 30)
age
```

```{r code21}
age <- c(Bob=25, Sue=21, John=30)
age
```
#### basic arithmetic with + - * / ^ log() exp() and so on
be careful with order of operations (use parentheses as needed)
```{r code22}
2 * 5 - 4 / 2 + 4
2 * ((5 - 4) / 2) + 4
-2^2
(-2)^2
log(2)   # natural log
log10(2) # log to base 10

exp(1)
```
#### a few special cases
```{r code23}
2/0
(-2)/0
0/0
```
Note: NaN = not a number (https://en.wikipedia.org/wiki/NaN) 

#### Scientific notation
```{r code24}
100000000
10^8
0.00000001
10^-8
```
if you find scientific notation confusing
```{r code25}
options(scipen=100)

100000000
0.00000001
```
if you want to, you can set 'scipen' back to the default (0)
```{r code26}
options(scipen=0)
```
Note: changes to the options are not permanent (if you restart R/RStudio,the default settings are in effect)


let's check if our computers are broken
```{r code27}
sqrt(2)
sqrt(2) * sqrt(2)
sqrt(2) * sqrt(2) - 2
```
what is going on here?
```{r code28}
print(sqrt(2) * sqrt(2), digits=18)
```
what is happening here?

this is actually a FAQ: https://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f

#### Vectorized operations
```{r code29}
x <- c(2,4,3,5,7)
x
```

```{r code30}
x * 2
x^2
log(x)
```

an example of a non-vectorized operation
```{r code31}
mean(x)
```

an example where we use vectorized and non-vectorized functions
```{r code32}
x
x - mean(x)
(x - mean(x))^2
sum((x - mean(x))^2)
sum((x - mean(x))^2) / (length(x)-1)
sqrt(sum((x - mean(x))^2) / (length(x)-1))

sd(x)
```

<br>

### **Data Frames** 
Most datasets are just a bunch of vectors (of the same length) combined into a 'data frame'; let's create such an object manually
```{r code33.1}
id  <- 1:3
age <- c(25, 21, 30)
sex <- c("Male", "Male", "Female")
grp <- c("T", "C", "T")

dat <- data.frame(id, age, sex, grp)
dat
```

<br>

Notes:
on the very left, we have the row names (not a variable!)

- character variables are not shown with quotes

- in the Environment pane, we now have a 'Data' object called 'dat'

- can click on 'dat' to view the contents (more useful for larger datasets)

- this is not for editing; we do not make any manual changes to our data!
- this is the same as using the **View()** command

```{r code34}
View(dat)
```

R is not Excel ...Clean up the workspace a bit (keep things tidy!)

```{r code37}
ls()

rm(id, age, grp, sex)

ls()
```
Accessing individual variables
```{r code38}
dat$id
dat$age
dat$sex
dat$grp
```
Note: in older versions of R, putting a character variable (e.g., sex, grp) into a data frame would turn it into a 'factor' (more on factors later)

<br>

### **Matrices** 
Two dimensions same as Dataframe but all columns in a matrix must have the same mode(numeric, character, etc.) 

<br>

### **Arrays** 

<br>

Arrays are similar to matrices but can have more than two dimensions. See help(array) for details.

### **Lists** 
An ordered collection of objects (components). A list allows you to gather a variety of (possibly unrelated) objects under one name.
```{r code383838}
# example of a list with 4 components -
# two string, one numeric vectors and one factor
w <- list(name="Fred", mynumbers=c(1:10), mycharacter=c("Male", "Female", "Female"), age=factor(c("0","1","1","1")))
w
```

<br>

### **Factors** 

Tell R that a variable is nominal by making it a factor. The factor stores the nominal values as a vector of integers in the range [ 1... k ] (where k is the number of unique values in the nominal variable), and an internal vector of character strings (the original values) mapped to these integers.
```{r code383839}
gender <- c("Male","Male","Male","Male","Female","Male","Male","Female","Male")
gender <- factor(gender)
# 1=female, 2=male internally (alphabetically)
# R now treats gender as a nominal variable
summary(gender) 
```

<br>

### **Manipulating the data frame** 

Subsetting (value before the comma is the row, value after is the column)
```{r code380}
dat
dat[1,2]
```
subsetting (columns)
```{r code381}
dat[,2]
dat[,c(1,4)]
```
Note: if you take a single column, you get a vectorfor data frames, we can also use a special notation to select columns
```{r code382}
dat[2]
dat[c(1,4)]
```
Note: taking a single column returns a data frame with that column can also refer to columns by their variable names
```{r code383}
dat[,"age"]
dat[,c("id","grp")]
```

```{r code384}
dat["age"]
dat[c("id","grp")]
```
subsetting (rows)
```{r code385}
dat[1,]
dat[c(1,2),]
```
combine selection of rows and columns
```{r code386}
dat[1:2, c("id","grp")]
```
subsetting with logicals
```{r code387}
dat$sex
dat$sex == "Male"
dat[dat$sex == "Male",]
```
Note: this will just return the dataset for the males, but this is not a permanent selection; examine object 'dat' again
```{r code388}
dat
```
If you want to make a permanent selection, you have to assign this output to an object (either overwrite the original object or make new ones)
```{r code389}
dat.m <- dat[dat$sex == "Male",]
dat.f <- dat[dat$sex == "Female",]
dat.m
dat.f
```
Note: in R, we can have an unlimited number of objects (including dataframes) available at the same time (see Environment pane); this can get confusing quickly, so try to keep your workspace tidy
```{r code3810}
rm(dat.m)
rm(dat.f)
```

using the subset() command
```{r code3811}
subset(dat, sex == "Male")
subset(dat, age >= 25)
subset(dat, grp == "T")
```
Overwrite the original object if you really don't need the rest of the data anymore further in the script (but don't do this now!)

dat <- subset(dat, sex == "Male")

subset() can subset rows and also select one or multiple columns
```{r code3812}
subset(dat, sex == "Male", select = age)
subset(dat, sex == "Male", select = c(age, sex))
subset(dat, sex == "Male", select = age, drop=TRUE)
```
add a new variable to a data frame
```{r code3840}
dat$y <- c(5, 7, 999)
dat
```
make a copy of an object
```{r code3813}
dat2 <- dat
dat2
```
sort a vector
```{r code3814}
dat2$age
sort(dat2$age)
dat2
```
as before, this is not a permanent change unless you 'back assign' it
```{r code3815}
dat2$age <- sort(dat2$age)
dat2
```
Note: this is NOT the right way to sort a data frame; it just sorts the age variable within dat2, but all of the other variables are unchanged!
```{r code3816}
rm(dat2)
```
How to sort a data frame
```{r code3817}
dat
order(dat$age)
```
```{r code38171}
dat[order(dat$age),]
dat
```

```{r code3818}
dat <- dat[order(dat$age),]
dat
```

Value replacement (suppose 999 actually stands for missing data)
```{r code3819}
dat$y
dat$y==999
dat$y[dat$y==999] <- NA
dat
```

```{r code3820}
dat$age[dat$age > 24] <- 24
dat
```

```{r code3821}
dat$y[dat$age <= 21] <- 4
dat
```

```{r code3822}
dat$y[3] <- 8
dat
```

```{r code3823}
dat$y[dat$id == 2] <- 5
dat
```
Rename a variable

```{r code3824}
dat
names(dat)
names(dat)[1]
names(dat)[1] <- "subject"
dat
```

```{r code3825}
names(dat)
names(dat) == "age"
names(dat)[names(dat) == "age"] <- "years"
dat
```
Remove a variable from a data frame

```{r code3826}
dat
dat$y <- NULL
dat
```
Generate a new variable based on an existing one

```{r code3827}
dat$days <- dat$years * 365
dat
```
sum/mean of several variables
```{r code3828}
dat$y1 <- c(2, 4, 3)
dat$y2 <- c(5, 5, 1)
dat
```
```{r code3829}
dat$ysum  <- dat$y1 + dat$y2
dat$ymean <- (dat$y1 + dat$y2) / 2
dat
```

There are special functions for this
```{r code3830}
dat$ysum  <- NULL
dat$ymean <- NULL
dat
dat[c("y1","y2")]
```

```{r code3831}
dat$ysum  <- rowSums(dat[c("y1","y2")])
dat$ymean <- rowMeans(dat[c("y1","y2")])
dat
```

what if there are missing values?
```{r code3832}
dat$y1[2] <- NA
dat
```

then the resulting mean/sum will also be NA
```{r code3833}
dat$ymean <- rowMeans(dat[c("y1","y2")])
dat
```
can avoid this with the 'na.rm' argument (set it to TRUE); then the mean or sum is taken over the non-missing values within each row
```{r code3834}
dat$ymean <- rowMeans(dat[c("y1","y2")], na.rm=TRUE)
dat
```

subsetting when there are missing values
```{r code3835}
dat
dat$y1 >= 2
dat[dat$y1 >= 2,] # not good
```

better but complex
```{r code3836}
is.na(dat$y1)
!is.na(dat$y1)
!is.na(dat$y1) & dat$y1 >= 2
dat[!is.na(dat$y1) & dat$y1 >= 2,]
```
easier
```{r code3837}
dat$y1 >= 2
which(dat$y1 >= 2)
dat[which(dat$y1 >= 2),]
```
easiest
```{r code3838}
subset(dat, y1 >= 2)
```
a couple other examples
```{r code3839}
dat
subset(dat, !is.na(y1))
subset(dat, subject != 1)
```



